<html lang="en">

<head>
  <title>Drug Graph visualizer</title>

  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="main.js"></script>
  
  <style type="text/css">
    #mynetwork {
      width: 800px;
      height: 800px;
      border: 1px solid lightgray;
    }
  </style>
</head>

<body>
  <h2>Drug Graph network - click on one product to show tree</h2>
  <div style="width: 800px; font-size: 14px">
    This example shows the power of the DataSet. Once a node is clicked, all
    nodes are greyed out except for the first and second order connected
    nodes. In this example we show how you can determine the order of
    connection per node as well as applying individual styling to the nodes
    based on whether or not they are connected to the selected node. The code
    doing the highlighting only takes about 1ms, the rest of the time is the
    redrawing of the network (9200 edges..).
    <br /><br />
  </div>   
   <div id="mynetwork"></div>
    <br />
    <script type="text/javascript">
      var network;
      var allNodes;
      var highlightActive = false;
      var nodesDataset = new vis.DataSet(nodes); // these come from WorldCup2014.js
      var edgesDataset = new vis.DataSet(edges); // these come from WorldCup2014.js
      // get a JSON object
      allNodes = nodesDataset.get({ returnType: "Object" });
      allEdges = edgesDataset.get({ returnType: "Object" });

      var container = document.getElementById("mynetwork");

      function redrawAll() {
        var options = {
          nodes: {
            font: {
              size: 12,
              face: "Tahoma",
            },
          },
          edges: {
            width: 0.15,
            color: { inherit: "from" },
            smooth: {
              type: "continuous",
            },
          },
          interaction: {
            tooltipDelay: 200,
            hideEdgesOnDrag: true,
            hideEdgesOnZoom: true,
          },       
          layout: {
            hierarchical: {
              direction: "UD",
              sortMethod: "directed",
            },
          },
          physics: {
            hierarchicalRepulsion: {
              avoidOverlap: 2,
            },
          },
        };
        


        // transform the object into an array
        var updateArray = [];
        for (edgeId in allEdges) {
          allEdges[edgeId].hidden=true;
          updateArray.push(allEdges[edgeId]);

        }
        edgesDataset.update(updateArray);
        // transform the object into an array
        var updateArray = [];
        for (nodeId in allNodes) {
          if (allNodes[nodeId].productType!="Substance"){
            allNodes[nodeId].hidden=true
          }
          updateArray.push(allNodes[nodeId]);

        }
        nodesDataset.update(updateArray);

        var data = { nodes: nodesDataset, edges: edgesDataset }; // Note: data is coming from ./datasources/WorldCup2014.js

        network = new vis.Network(container, data, options);

        network.on("click", neighbourhoodHighlight);
      }

      function get_neibours(degrees, selectedNode) {


        // hid all nodes
        for (var nodeId in allNodes) {

          allNodes[nodeId].hidden = true;

        }
        // mark all edges as hidden
        for (var edgeId in allEdges) {

          allEdges[edgeId].hidden = true;

        }
        allNodes[selectedNode].hidden = false;

        var connectedNodes = network.getConnectedNodes(selectedNode);
        var connectedEdges = network.getConnectedEdges(selectedNode);
        var allConnectedNodes = connectedNodes;
        var allConnectedEdges = connectedEdges;
        /* var allConnectedNodes = [];
        var allConnectedEdges = [];
        
        // get the second degree nodes
        for (i = 1; i < degrees; i++) {
          for (j = 0; j < connectedNodes.length; j++) {
            allConnectedNodes = allConnectedNodes.concat(
              network.getConnectedNodes(connectedNodes[j])
            );
            console.log(network.getConnectedEdges(connectedNodes[j]))
            allConnectedEdges = allConnectedEdges.concat(
              network.getConnectedEdges(connectedNodes[j])
            );
          }
        }
        console.log(allConnectedNodes)
        console.log(allConnectedEdges)
        */
        // remove hidden from showing nodes
        for (i = 0; i < allConnectedNodes.length; i++) {

          allNodes[allConnectedNodes[i]].hidden = false;


        }
        // remove hidden from showing edges
        for (i = 0; i < allConnectedEdges.length; i++) {
          allEdges[allConnectedEdges[i]].hidden = false;


        }
        return [allConnectedNodes, allConnectedEdges]
      }

      function neighbourhoodHighlight(params) {
        // if something is selected:
        if (params.nodes.length > 0) {
          highlightActive = true;
          var i, j;
          var selectedNode = params.nodes[0];
          var result = get_neibours(2, selectedNode)
          allConnectedNodes = result[0]
          allConnectedEdges = result[1]

        } else if (highlightActive === true) {
          // reset all nodes
          for (var nodeId in allNodes) {
            allNodes[nodeId].hidden = false;

          }
          for (var edgeId in allEdges) {
            allEdges[edgeId].hidden = false;

          }
          highlightActive = false;
        } 


        // transform the object into an array
        var updateArray = [];
        for (nodeId in allNodes) {
          updateArray.push(allNodes[nodeId]);

        }
        nodesDataset.update(updateArray);

        // transform the object into an array
        var updateArray = [];
        for (edgeId in allEdges) {
          updateArray.push(allEdges[edgeId]);

        }
        edgesDataset.update(updateArray);

      }
      redrawAll();
    </script>
</body>

</html>